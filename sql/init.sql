-- 1. Create the profiles table (for extending user information)

-- Here, the id is directly associated with the id in auth.users, ensuring a one-to-one correspondence
create table public.profiles (
  id uuid not null references auth.users(id) on delete cascade primary key,
  username text unique,
  nickname text,
  avatar_url text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS (Row Level Security)
alter table public.profiles enable row level security;

-- Policy: Public profiles are viewable by everyone (adjust based on business needs)
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

-- Policy: Users can insert their own profile.
create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update their own profile."
  on profiles for update
  using ( auth.uid() = id );

-- 2. Create the refresh_tokens table (core authentication table)
create table public.refresh_tokens (
  id bigint generated by default as identity primary key,

  -- Associated user, tokens are automatically cleaned up when the user is deleted
  user_id uuid not null references auth.users(id) on delete cascade,

  -- Core security field: store Hash, not plaintext
  token_hash text not null,

  -- Device fingerprint and metadata
  device_id text not null,       -- Unique device ID generated by the frontend (UUID)
  device_info jsonb default '{}'::jsonb, -- Store User-Agent, IP, OS, etc.

  -- State management
  is_revoked boolean default false, -- Revocation flag

  -- Lifecycle
  created_at timestamptz default now(),
  expires_at timestamptz not null,  -- Absolute expiration time
  parent_id bigint references public.refresh_tokens(id) -- Optional: used to track token rotation chain
);

-- 3. Create indexes (performance optimization)
-- High-frequency operation: find records by Token Hash (used in /token refresh endpoint)
create index idx_refresh_tokens_hash on public.refresh_tokens(token_hash);

-- High-frequency operation: find all devices of a user (used in /devices list endpoint)
create index idx_refresh_tokens_user on public.refresh_tokens(user_id);

-- 4. (Optional) Auto trigger: update profiles.updated_at
create function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger on_profiles_updated
  before update on public.profiles
  for each row execute procedure public.handle_updated_at();

-- 5. (Optional) Auto-trigger: Automatically insert profiles for new user registrations
-- If you are directly using Supabase Auth's registration API, this is useful
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, nickname, avatar_url)
  values (new.id, new.raw_user_meta_data->>'nickname', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
